!---------------------------------------------------------------------
!Module: Minnesota
!---------------------------------------------------------------------
!> The interaction part of the potential can be calculated relatively
!! simply using the Minnesota potential for \f$l=0\f$ (using the
!! subroutine \f$\texttt{calculate\_TBME}\f$), or you can read in the
!! m-scheme matrix elements
!! from a file generated by Morten's \f$\texttt{vNN}\f$ code. Finally,
!! you can estimate the potential using the Local-Density Approximation
!! or the Density Matrix Expansion (although that capability resides in
!! a separate module, \f$\texttt{HF\_LDA.f90}\f$).
!---------------------------------------------------------------------
module Minnesota
  use :: types
  use :: variables
  use :: HO_Quadrature
  implicit none
  real(dp), private, parameter :: V0R=200.00_dp, muR=1.487_dp !< Parameters for the
  real(dp), private, parameter :: V0s= 91.85_dp, mus=0.465_dp !< Minnesota potential
  real(dp), private, parameter :: hw=10._dp, hbar=197.327_dp, M_n=939.57_dp
  real(dp), private, parameter :: h2_2m = 20.736209412_dp
  real(dp), private, parameter :: b_ho=sqrt(2*h2_2m/hw)
contains

!> Reads the file \f$\texttt{spM.dat}\f$ generated by Morten's
!! \f$\texttt{vNN}\f$ code and stores, for each particle, the quantum
!! numbers \f$n, h, j, m,\f$ and the isospin projection. Currently it is
!! configured to flag neutron states (by
!! setting \f$\texttt{hf\_flag(i)=1}\f$). Since we won't need every state
!! in the list for a calculation, the array \f$\texttt{HO\_inverse}\f$ is
!! used to match the index j (referred to by the m-scheme two-body term
!! \f$V(j_1,j_2,j_3,j_4)\f$ - see RHS of eq. 4 of HF_fullspherical.pdf)
!! with the index of the corresponding state in the \f$\texttt{spM.dat}\f$
!! list(indexed by i).
  subroutine read_orbitals
    implicit none
    integer :: i,j
    character(20) :: text
    integer :: ni,li,ji,mi,tzi
    allocate(HO_inverse(1:n_orbitals))
    allocate(ho_flag(1:n_orbitals))
    allocate(n_ho(1:n_orbitals))
    allocate(m_ho(1:n_orbitals))
    allocate(l_ho(1:n_orbitals))
    allocate(j_ho(1:n_orbitals))
    allocate(tz_ho(1:n_orbitals))
    allocate(n_hf(1:n_orbitals))
    allocate(l_hf(1:n_orbitals))
    allocate(j_hf(1:n_orbitals))
    open(100,file='spM_n5l2.dat')
    do i = 1,1
       read(100,*)
    enddo
    n_hf = 0
    l_hf = 0
    j_hf = 0
    HO_inverse = 0
    ho_flag = 0
    j = 0
    do i = 1,n_orbitals
       read(100,'(a20,6i4)') text, ni,li,ji,mi,tzi
       n_ho(i) = ni
       l_ho(i) = li
       j_ho(i) = ji
       m_ho(i) = mi
       tz_ho(i) = tzi
       if(tzi.eq.1) then
          ho_flag(i) = 1
          if(ni.ne.n_ho(i-1).or.li.ne.l_ho(i-1).or.ji.ne.j_ho(i-1)&
               .or.tzi.ne.tz_ho(i-1)) then
             j = j + 1
             n_hf(j) = ni
             l_hf(j) = li
             j_hf(j) = ji
           endif
           HO_inverse(i) = j
      endif
    enddo
    close(100)
    nsize = j
  end subroutine read_orbitals

!> Reads the \f$\texttt{VM-scheme.dat}\f$ file generated by Morton's code.
!! The first four columns refer back to specific single-particle states
!! indexed in \f$\texttt{spM.dat}\f$, and the final column gives the
!! corresponding two-body matrix element. It uses the
!! \f$\texttt{ho\_flag}\f$ array to import only neutron states. It
!! returns the \f$m,m'\f$-averaged two- body matrix element (eq. 4 of
!! HF_fullspherical.pdf).
  subroutine read_TBME
    implicit none
    integer :: i1,i2,i3,i4,tz,P,J
    integer :: j1,j2,j3,j4
    integer :: k1,k2,k3,k4
    real(dp) :: TBME
    allocate(v_mat(1:Nsize,1:Nsize,1:Nsize,1:Nsize))
    v_mat = 0
    open(100,file='VM-scheme_n5l2.dat')
    read(100,*)
    read(100,*)
    do
       read(100,*) i1,i2,i3,i4,TBME
       if(i1.eq.0) exit 
       if(ho_flag(i1).eq.1.and.ho_flag(i2).eq.1.and.&
            ho_flag(i3).eq.1.and.ho_flag(i4).eq.1) then
          if(m_ho(i1).ne.m_ho(i3).or.m_ho(i2).ne.m_ho(i4)) cycle
          j1 = HO_inverse(i1)
          j2 = HO_inverse(i2)
          j3 = HO_inverse(i3)
          j4 = HO_inverse(i4)
          v_mat(j1,j2,j3,j4) = v_mat(j1,j2,j3,j4) + &
               1/((j_ho(i1)+1._dp)*(j_ho(i2)+1._dp))*TBME
       endif
    enddo
    close(100)
  end subroutine read_TBME

!> Initializes the one-body part of the Hamiltonian, that is, the
!! first term \f$t_{\alpha\beta}\f$ in eq. 2 of HF_truncated_v2.pdf.
!! The matrix is diagonal in the harmonic oscillator basis (which
!! we start from), and its eigenvalues are given by
!! \f$\hbar\omega\left(2n+l+\frac{3}{2}\right)\f$.
  subroutine Initialize_Minnseota
    implicit none
    integer :: i,n,np,l
    real(dp) :: alpha,xi,xj,wi,wj,A1,A2,A3,A4,s,L1,L2
    integer, parameter :: Ngauss = 95
    real(dp), dimension(1:Ngauss) :: w,x
    allocate(t_mat(1:Nsize,1:Nsize))
    t_mat = 0
    do i = 1,nsize
       t_mat(i,i) = hw*(2*n_hf(i) + l_hf(i) + 1.5_dp)
    enddo
  end subroutine Initialize_Minnseota

!> Given the number of particles \f$\texttt{Nparticles}\f$,
!! finds the number of occupied levels in the system.
  function fermi_level() result(Noccupied)
    integer :: i,j,k,Noccupied
    k=1
    do i = 1,n_orbitals
        j = HO_inverse(i)

        if (j.ne.0.and.k.le.Nparticles) then
         Noccupied = j
         k=k+1
     elseif (k.gt.Nparticles) then
         write (*,*) "nOccupied = ", Noccupied
         exit
     endif
    end do
  end function fermi_level

!> Calls the function Minnesota_TBME to calculate the two-body
!! matrix elements, and stores the result in an array such that
!! \f$V_{i_1i_2i_3i_4}= V_{i_1i_2i_4i_3}=V_{i_2i_1i_3i_4}=V_{i_2i_1i_4i_3}\f$.
!! Consequnetly, these matrix elements respect fermion
!! antisymmetry [see HF_truncated_v2.pdf eqns. 17-21].
 subroutine calculate_TBME
    implicit none
    integer :: n1,n2,n3,n4,i1,i2,i3,i4
    real(dp) :: M34, M43
    do i1 = 1,Nsize
       n1 = n_ho(i1)
       do i2 = i1,Nsize
          n2 = n_ho(i2)
          do i3 = 1,Nsize
             n3 = n_ho(i3)
             do i4 = i3,Nsize
                n4 = n_ho(i4)
                M34 = Minnesota_TBME(n1,n2,n3,n4)
                if(n3.eq.n4) then
                   M43 = M34
                else
                   M43 = Minnesota_TBME(n1,n2,n4,n3)
                endif
                v_mat(i1,i2,i3,i4) = M34+M43
                v_mat(i1,i2,i4,i3) = M34+M43
                v_mat(i2,i1,i3,i4) = M34+M43
                v_mat(i2,i1,i4,i3) = M34+M43
             enddo
          enddo
       enddo
    enddo
  end subroutine calculate_TBME

!> Using Gauss-Laguerre quadrature with weights \f$w_i\f$ and
!! \f$w_j\f$, performs the integral of the kernel created in
!! \f$\texttt{Minnesota\_Kernel}\f$, which, when normalized with
!! the harmonic oscillator coefficients \f$A_i\f$, gives the
!! value of the TBME matrix element \f$V_{n_1n_2n_3n_4}\f$.
!> \f$\texttt{Ngauss}\f$ is the number of mesh points used for
!! the Gauss-Laguerre quadrature; more than 100 seemed to lead
!! to problems so we set it to 95.
!> The case \f$\alpha=0.5\f$ is specific to the case \f$l=0\f$.
  function Minnesota_TBME(n1,n2,n3,n4) result(TBME)
    implicit none
    integer, intent(in) :: n1,n2,n3,n4
    integer :: i,j
    integer, parameter :: Ngauss = 95
    real(dp) :: TBME
    real(dp) :: alpha,xi,xj,wi,wj,A1,A2,A3,A4
    real(dp), dimension(1:Ngauss) :: w,x
    logical :: first_call = .true.
    save w,x
    if(first_call) then
       alpha = 0.5_dp
       call GaussLaguerreWX(alpha,w,x)
       first_call = .false.
    endif
    A1 = HO_Normalization(n1,0)
    A2 = HO_Normalization(n2,0)
    A3 = HO_Normalization(n3,0)
    A4 = HO_Normalization(n4,0)
    TBME = 0._dp
    do i = 1,Ngauss
       xi = x(i)
       wi = w(i)
       do j = 1, Ngauss
          xj = x(j)
          wj = w(j)
          TBME = TBME + wi*wj*Minnesota_Kernel(n1,n2,n3,n4,xi,xj)
       enddo
    enddo

    TBME = TBME*A1*A2*A3*A4/(4._dp)
  end function Minnesota_TBME

!> Sets up the kernel of the integral found in HF_truncated_v2.pdf eqn. 11
!! for the form of the Minnesota potential described in eqns. 26-29.
  function Minnesota_Kernel(n1,n2,n3,n4,xi,xj) result(MK)
    implicit none
    integer, intent(in) :: n1,n2,n3,n4
    real(dp), intent(in) :: xi,xj
    real(dp) :: MK
    real(dp) :: L1,L2,L3,L4,ri,rj
    call LaguerreL(n1,0.5_dp,xi,L1)
    call LaguerreL(n2,0.5_dp,xj,L2)
    call LaguerreL(n3,0.5_dp,xi,L3)
    call LaguerreL(n4,0.5_dp,xj,L4)
    ri = b_ho*sqrt(xi)
    rj = b_ho*sqrt(xj)
    MK = (V0R/mur*(Exp(-mur*(ri**2+rj**2-2*ri*rj))&
                  -Exp(-mur*(ri**2+rj**2+2*ri*rj))) &
         -V0s/mus*(Exp(-mus*(ri**2+rj**2-2*ri*rj))&
                  -Exp(-mus*(ri**2+rj**2+2*ri*rj))))&
                  *L1*L2*L3*L4/(4*ri*rj)*0.5_dp
  end function Minnesota_Kernel

end module Minnesota
